import { useEffect, useRef, useState } from 'react';
import EditorJS, { OutputData } from '@editorjs/editorjs';
import Header from '@editorjs/header';
import List from '@editorjs/list';
import Code from '@editorjs/code';
import Quote from '@editorjs/quote';
import Delimiter from '@editorjs/delimiter';
import DragDrop from 'editorjs-drag-drop';
import './ZenBlockEditor.css';


export type EditorTheme = 'dark' | 'light';

interface ZenBlockEditorProps {
  value: string; // Markdown input
  onChange: (value: string) => void; // Markdown output
  placeholder?: string;
  height?: string;
  fontSize?: number;
  wrapLines?: boolean;
  showLineNumbers?: boolean;
  theme?: EditorTheme;
  focusHeadingRequest?: { headingIndex: number; token: number } | null;
}

/**
 * ZenBlockEditor - Block-based editor powered by EditorJS
 * Allows users to either type freely or use block-based editing with formatting
 */
export const ZenBlockEditor = ({
  value,
  onChange,
  placeholder = 'Schreibe  was du denkst...',
  height = '400px',
  fontSize,
  wrapLines = true,
  showLineNumbers = true,
  theme = 'light',
  focusHeadingRequest = null,
}: ZenBlockEditorProps) => {
  const editorRef = useRef<EditorJS | null>(null);
  const holderRef = useRef<HTMLDivElement>(null);
  const [isReady, setIsReady] = useState(false);
  // Use ref to always have latest onChange callback (fixes closure bug)
  const onChangeRef = useRef(onChange);
  useEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);

  // Convert Markdown to EditorJS format
  const markdownToEditorJS = (markdown: string): OutputData => {
    if (!markdown.trim()) {
      return {
        time: Date.now(),
        blocks: [],
        version: '2.28.0',
      };
    }

    const blocks: any[] = [];
    const lines = markdown.split('\n');
    let i = 0;

    while (i < lines.length) {
      const line = lines[i];

      // Empty line - skip
      if (!line.trim()) {
        i++;
        continue;
      }

      // Headers (# ## ###)
      if (line.match(/^#{1,6}\s/)) {
        const level = line.match(/^#+/)?.[0].length || 1;
        const text = line.replace(/^#+\s/, '');
        blocks.push({
          type: 'header',
          data: {
            text,
            level: Math.min(level, 6),
          },
        });
        i++;
        continue;
      }

      // Code blocks (```)
      if (line.startsWith('```')) {
        const language = line.slice(3).trim() || '';
        const codeLines: string[] = [];
        i++; // Skip opening ```

        while (i < lines.length && !lines[i].startsWith('```')) {
          codeLines.push(lines[i]);
          i++;
        }

        blocks.push({
          type: 'code',
          data: {
            code: codeLines.join('\n'),
            language,
          },
        });
        i++; // Skip closing ```
        continue;
      }

      // Quotes (>)
      if (line.startsWith('>')) {
        const quoteLines: string[] = [line.replace(/^>\s?/, '')];
        i++;

        while (i < lines.length && lines[i].startsWith('>')) {
          quoteLines.push(lines[i].replace(/^>\s?/, ''));
          i++;
        }

        blocks.push({
          type: 'quote',
          data: {
            text: quoteLines.join('\n'),
            caption: '',
            alignment: 'left',
          },
        });
        continue;
      }

      // Lists (- or 1.)
      if (line.match(/^[\-\*]\s/) || line.match(/^\d+\.\s/)) {
        const isOrdered = line.match(/^\d+\.\s/) !== null;
        const items: string[] = [];
        const itemRegex = isOrdered ? /^\d+\.\s/ : /^[\-\*]\s/;

        while (i < lines.length && lines[i].match(itemRegex)) {
          items.push(lines[i].replace(itemRegex, ''));
          i++;
        }

        blocks.push({
          type: 'list',
          data: {
            style: isOrdered ? 'ordered' : 'unordered',
            items,
          },
        });
        continue;
      }

      // Delimiter (---)
      if (line.match(/^---+$/)) {
        blocks.push({
          type: 'delimiter',
          data: {},
        });
        i++;
        continue;
      }

      // Regular paragraph
      const paragraphLines: string[] = [line];
      i++;

      // Collect consecutive non-special lines
      while (
        i < lines.length &&
        lines[i].trim() &&
        !lines[i].match(/^#{1,6}\s/) &&
        !lines[i].startsWith('```') &&
        !lines[i].startsWith('>') &&
        !lines[i].match(/^[\-\*]\s/) &&
        !lines[i].match(/^\d+\.\s/) &&
        !lines[i].match(/^---+$/)
      ) {
        paragraphLines.push(lines[i]);
        i++;
      }

      blocks.push({
        type: 'paragraph',
        data: {
          text: paragraphLines.join(' '),
        },
      });
    }

    return {
      time: Date.now(),
      blocks,
      version: '2.28.0',
    };
  };

  // Convert EditorJS format to Markdown
  const editorJSToMarkdown = (data: OutputData): string => {
    if (!data.blocks || data.blocks.length === 0) {
      return '';
    }

    const normalizeInlineText = (text: string) => {
      const convertOrderedLists = (input: string) =>
        input.replace(/<ol(\s+[^>]*)?>([\s\S]*?)<\/ol>/gi, (_match, _attrs, inner) => {
          const items: string[] = [];
          const liRegex = /<li(\s+[^>]*)?>([\s\S]*?)<\/li>/gi;
          let m: RegExpExecArray | null;
          let idx = 1;
          while ((m = liRegex.exec(inner)) !== null) {
            const raw = m[2] ?? '';
            const cleaned = raw
              .replace(/<br\s*\/?>\s*<br\s*\/?>/gi, '\n\n')
              .replace(/<br\s*\/?>/gi, '  \n')
              .replace(/<[^>]+>/g, '')
              .trim();
            items.push(`${idx}. ${cleaned}`);
            idx += 1;
          }
          return items.join('\n');
        });

      return convertOrderedLists(text)
        .replace(/&nbsp;/gi, ' ')
        .replace(/<\/li>\s*<li(\s+[^>]*)?>/gi, '\n- ')
        .replace(/<li(\s+[^>]*)?>/gi, '- ')
        .replace(/<\/li>/gi, '\n')
        .replace(/<\/ol>/gi, '\n')
        .replace(/<\/ul>/gi, '\n')
        .replace(/<ol(\s+[^>]*)?>/gi, '')
        .replace(/<ul(\s+[^>]*)?>/gi, '')
        .replace(/<\/(p|div|h[1-6]|li|ul|ol|blockquote|pre|code)>/gi, '\n')
        .replace(/<(p|div|h[1-6]|li|ul|ol|blockquote|pre|code)(\s+[^>]*)?>/gi, '')
        .replace(/<\/?span(\s+[^>]*)?>/gi, '')
        .replace(/<\/?a(\s+[^>]*)?>/gi, '')
        .replace(/<\/?strong(\s+[^>]*)?>/gi, '')
        .replace(/<\/?em(\s+[^>]*)?>/gi, '')
        .replace(/<br\s*\/?>\s*<br\s*\/?>/gi, '\n\n')
        .replace(/<br\s*\/?>/gi, '  \n');
    };

    return data.blocks
      .map((block) => {
        switch (block.type) {
          case 'header':
            const level = '#'.repeat(block.data.level || 1);
            return `${level} ${normalizeInlineText(block.data.text || '')}`;

          case 'paragraph':
            return normalizeInlineText(block.data.text || '');

          case 'list':
            const style = block.data.style === 'ordered' ? '1.' : '-';
            return block.data.items
              .map((item: string, index: number) => {
                if (block.data.style === 'ordered') {
                  return `${index + 1}. ${normalizeInlineText(item)}`;
                }
                return `${style} ${normalizeInlineText(item)}`;
              })
              .join('\n');

          case 'code':
            const lang = block.data.language || '';
            return `\`\`\`${lang}\n${block.data.code}\n\`\`\``;

          case 'quote':
            return normalizeInlineText(block.data.text || '')
              .split('\n')
              .map((line: string) => `> ${line}`)
              .join('\n');

          case 'delimiter':
            return '---';

          default:
            return '';
        }
      })
      .join('\n\n');
  };

  // Initialize EditorJS
  useEffect(() => {
    if (!holderRef.current || editorRef.current) return;

    const editor = new EditorJS({
      holder: holderRef.current,
      placeholder,
      tools: {
        header: {
          class: Header as any,
          inlineToolbar: true,
          config: {
            levels: [1, 2, 3, 4, 5, 6],
            defaultLevel: 2,
          },
        },
        list: {
          class: List as any,
          inlineToolbar: true,
        },
        code: {
          class: Code as any,
        },
        quote: {
          class: Quote as any,
          inlineToolbar: true,
        },
        delimiter: Delimiter as any,
      },
      data: markdownToEditorJS(value),
      onChange: async () => {
        if (!editorRef.current) return;

        try {
          const outputData = await editorRef.current.save();
          const markdown = editorJSToMarkdown(outputData);
          // Use ref to always call the latest onChange callback
          onChangeRef.current(markdown);
        } catch (error) {
          console.error('Error saving EditorJS data:', error);
        }
      },
      onReady: () => {
        setIsReady(true);

        // Enable drag-and-drop
        if (editorRef.current) {
          new DragDrop(editorRef.current);
        }
      },
    });

    editorRef.current = editor;

    return () => {
      if (editorRef.current && editorRef.current.destroy) {
        editorRef.current.destroy();
        editorRef.current = null;
      }
    };
  }, []);

  // Update editor when value changes externally
  useEffect(() => {
    if (!isReady || !editorRef.current) return;

    const updateEditor = async () => {
      try {
        const currentData = await editorRef.current!.save();
        const currentMarkdown = editorJSToMarkdown(currentData);

        // Only update if the markdown has actually changed
        if (currentMarkdown !== value) {
          await editorRef.current!.render(markdownToEditorJS(value));
        }
      } catch (error) {
        console.error('Error updating editor:', error);
      }
    };

    updateEditor();
  }, [value, isReady]);

  useEffect(() => {
    if (!focusHeadingRequest) return;
    if (!isReady || !holderRef.current) return;

    const headingNodes = holderRef.current.querySelectorAll<HTMLElement>('.ce-header, .cdx-header');
    if (headingNodes.length === 0) return;

    const targetIndex = Math.max(0, Math.min(focusHeadingRequest.headingIndex, headingNodes.length - 1));
    const targetNode = headingNodes[targetIndex];
    if (!targetNode) return;

    targetNode.scrollIntoView({ behavior: 'smooth', block: 'center' });
    targetNode.focus();

    const originalOutline = targetNode.style.outline;
    const originalOutlineOffset = targetNode.style.outlineOffset;
    targetNode.style.outline = '1px solid #AC8E66';
    targetNode.style.outlineOffset = '2px';
    window.setTimeout(() => {
      targetNode.style.outline = originalOutline;
      targetNode.style.outlineOffset = originalOutlineOffset;
    }, 700);
  }, [focusHeadingRequest, isReady]);

  // Theme-based colors
  const themeStyles = {
    dark: {
      background: '#151515',
      text: '#dbd9d5',
      placeholder: '#dbd9d5',
      border: '#AC8E66',
      BorderStyle: 'dotted',
    },
    light: {
      background: '#D9D4C5',
      text: '#1a1a1a',
      placeholder: '#6b6b6b',
      border: '#AC8E66',
    },
  };

  const colors = themeStyles[theme];

  const className = [
    'zen-block-editor',
    wrapLines ? '' : 'zen-editor-nowrap',
    showLineNumbers ? 'zen-editor-line-numbers' : '',
    `zen-editor-theme-${theme}`,
  ]
    .filter(Boolean)
    .join(' ');

  // Capture-phase listener: fires BEFORE EditorJS handles the click
  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const el = containerRef.current;
    if (!el || !showLineNumbers) return;

    const handler = (e: MouseEvent) => {
      const rect = el.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      if (clickX > 56) return;

      e.preventDefault();
      e.stopPropagation();

      const blocks = el.querySelectorAll('.ce-block');
      for (const block of blocks) {
        const blockRect = block.getBoundingClientRect();
        if (e.clientY >= blockRect.top && e.clientY <= blockRect.bottom) {
          const contentEl = block.querySelector('.ce-block__content');
          if (contentEl) {
            const range = document.createRange();
            range.selectNodeContents(contentEl);
            const sel = window.getSelection();
            sel?.removeAllRanges();
            sel?.addRange(range);
          }
          break;
        }
      }
    };

    el.addEventListener('mousedown', handler, true); // capture phase
    return () => el.removeEventListener('mousedown', handler, true);
  }, [showLineNumbers]);

  return (
    <div
      ref={containerRef}
      className={className}
      style={{
        border: `1px solid ${colors.border}`,
        borderRadius: 8,
        backgroundColor: colors.background,
        overflow: 'auto',
        height,
        fontFamily: '"IBM Plex Mono", "Courier Prime", ui-monospace, SFMono-Regular, monospace',
        ...(fontSize ? { ['--zen-editor-font-size' as any]: `${fontSize}px` } : {}),
        ['--zen-editor-placeholder' as any]: colors.placeholder,
        ['--color-placeholder' as any]: colors.placeholder,
        ['--color-text-secondary' as any]: colors.placeholder,
        position: 'relative',
      }}
    >
      <div
        ref={holderRef}
        style={{
          padding: 16,
          color: colors.text,
        }}
      />
    </div>
  );
};
